<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Microfluidic Chip Analyzer</title>
<script src="https://cdn.jsdelivr.net/npm/plotly.js-dist@2.28.0/plotly.min.js"></script>

<style>
  body {
    margin: 0;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: #f8fafc;
    color: #1f2937;
  }

  .container {
    max-width: 1200px;
    margin: auto;
    padding: 40px 20px;
  }

  h1 {
    text-align: center;
    font-weight: 600;
    margin-bottom: 40px;
  }

  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
  }

  .card {
    background: #ffffff;
    border-radius: 14px;
    padding: 25px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border: 1px solid #e5e7eb;
  }

  .upload-box {
    border: 2px dashed #9ca3af;
    border-radius: 12px;
    padding: 40px 20px;
    text-align: center;
    color: #6b7280;
    cursor: pointer;
    transition: all 0.2s ease;
    background: #f9fafb;
  }

  .upload-box:hover {
    border-color: #3b82f6;
    background: #eff6ff;
    color: #1e40af;
  }

  canvas {
    width: 100%;
    margin-top: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  }

  .results-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 20px;
  }

  .results {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
  }

  .result-card {
    background: #f9fafb;
    border-radius: 12px;
    padding: 18px;
    border: 1px solid #e5e7eb;
  }

  .result-card h3 {
    margin: 0 0 10px 0;
    font-weight: 500;
    font-size: 16px;
  }

  .value {
    font-size: 26px;
    font-weight: 600;
  }

  .status-positive {
    color: #059669;
  }

  .status-negative {
    color: #dc2626;
  }

  .label {
    font-size: 13px;
    color: #6b7280;
    margin-top: 6px;
  }

  .curve-title {
    text-align: center;
    font-size: 18px;
    font-weight: 500;
    margin-bottom: 15px;
  }

</style>
</head>

<body>
<div class="container">
  <h1>Microfluidic Chip Analyzer</h1>

  <div class="grid">

    <!-- LEFT: IMAGE UPLOAD -->
    <div class="card">
      <div class="upload-box" id="uploadBox">
        ðŸ“· Click to upload chip image
      </div>
      <input type="file" id="fileInput" accept="image/*" style="display:none">
      <canvas id="canvas"></canvas>
    </div>

    <!-- RIGHT: RESULTS -->
    <div class="card">
      <div class="results-title">Analysis Results</div>
      <div class="results" id="results" style="display:none;">
        <div class="result-card">
          <h3>Zone 1 â€” MDA Concentration</h3>
          <div class="value" id="mdaValue">-- ÂµM</div>
          <div class="label" id="mdaDetails"></div>
        </div>

        <div class="result-card">
          <h3>Zone 2 â€” Rheumatoid Factor (RF)</h3>
          <div class="value" id="rfStatus">--</div>
          <div class="label">Qualitative detection</div>
        </div>

        <div class="result-card">
          <h3>Zone 3 â€” Anti-CCP</h3>
          <div class="value" id="ccpStatus">--</div>
          <div class="label">Qualitative detection</div>
        </div>
      </div>
    </div>

  </div>

  <!-- CALIBRATION CURVE -->
  <div class="card" style="margin-top: 40px;">
    <div class="curve-title">MDA Calibration Curve</div>
    <div id="calibrationPlot" style="width:100%; height:450px;"></div>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const fileInput = document.getElementById("fileInput");
const uploadBox = document.getElementById("uploadBox");

const mdaValue = document.getElementById("mdaValue");
const mdaDetails = document.getElementById("mdaDetails");
const rfStatus = document.getElementById("rfStatus");
const ccpStatus = document.getElementById("ccpStatus");
const resultsBox = document.getElementById("results");

// Calibration for NMPI-MDA (BLUE INTENSITY METHOD)
// Since MORE BLUE = MORE MDA, we use direct linear relationship
// Formula: concentration = (blue_intensity - INTERCEPT) / SLOPE
// You need to measure YOUR actual blue values and update these!

const SLOPE = 3.5;          // UPDATE: Blue intensity increase per ÂµM MDA (approx 3.5 units per ÂµM)
const INTERCEPT = 100;      // UPDATE: Baseline blue intensity at 0 ÂµM
const R_SQUARED = 0.9865;   // UPDATE: RÂ² from your calibration

// Example calibration points for plotting (UPDATE WITH YOUR DATA!)
// Format: {conc: MDA concentration (ÂµM), abs: Blue intensity (0-255)}
const calibrationData = [
  {conc: 10, abs: 135},   // PLACEHOLDER - measure actual blue values!
  {conc: 20, abs: 170},   // PLACEHOLDER
  {conc: 30, abs: 205},   // PLACEHOLDER
  {conc: 40, abs: 240}    // PLACEHOLDER
];

// BLANK RGB VALUE - measure from your blank sample!
const BLANK_R = 255;  // Not used for blue intensity method
const BLANK_G = 255;  // Not used for blue intensity method
const BLANK_B = 100;  // Baseline blue intensity for blank

// Trigger file input
uploadBox.addEventListener("click", () => fileInput.click());
fileInput.addEventListener("change", loadImage);

// ---------------- IMAGE LOAD ----------------
function loadImage(event) {
  const file = event.target.files[0];
  if (!file) return;

  const img = new Image();
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
    autoDetectZones();
  };
  img.src = URL.createObjectURL(file);
}

// ---------------- AUTO ZONE DETECTION ----------------
function autoDetectZones() {
  const w = canvas.width;
  const h = canvas.height;

  // Updated positions based on actual chip layout
  const zones = {
    1: ctx.getImageData(w * 0.40, h * 0.70, w * 0.15, h * 0.20),  // Bottom center (Zone 1)
    2: ctx.getImageData(w * 0.10, h * 0.40, w * 0.15, h * 0.20),  // Left side (Zone 2)
    3: ctx.getImageData(w * 0.75, h * 0.40, w * 0.15, h * 0.20)   // Right side (Zone 3)
  };

  drawZoneBoxes(w, h);
  analyze(zones);
}

// ---------------- DRAW ZONE BOXES ----------------
function drawZoneBoxes(w, h) {
  // Zone 1 - Bottom center (Blue box)
  ctx.strokeStyle = '#38bdf8';
  ctx.lineWidth = 3;
  ctx.strokeRect(w * 0.40, h * 0.70, w * 0.15, h * 0.20);
  ctx.fillStyle = '#38bdf8';
  ctx.font = 'bold 24px Arial';
  ctx.fillText('1', w * 0.42, h * 0.73);

  // Zone 2 - Left side (Green box)
  ctx.strokeStyle = '#22c55e';
  ctx.strokeRect(w * 0.10, h * 0.40, w * 0.15, h * 0.20);
  ctx.fillStyle = '#22c55e';
  ctx.fillText('2', w * 0.12, h * 0.43);

  // Zone 3 - Right side (Red box)
  ctx.strokeStyle = '#ef4444';
  ctx.strokeRect(w * 0.75, h * 0.40, w * 0.15, h * 0.20);
  ctx.fillStyle = '#ef4444';
  ctx.fillText('3', w * 0.77, h * 0.43);
}

// ---------------- RGB ANALYSIS (NEW METHOD) ----------------
function analyzeRGB(imageData) {
  const data = imageData.data;
  let totalR = 0, totalG = 0, totalB = 0;
  const totalPixels = data.length / 4;

  for (let i = 0; i < data.length; i += 4) {
    totalR += data[i];
    totalG += data[i + 1];
    totalB += data[i + 2];
  }

  const avgR = totalR / totalPixels;
  const avgG = totalG / totalPixels;
  const avgB = totalB / totalPixels;

  return { avgR, avgG, avgB };
}

// ---------------- CALCULATE ABSORBANCE ----------------
function calculateAbsorbance(sampleValue, blankValue) {
  // A = -log(I/I0)
  if (sampleValue <= 0 || blankValue <= 0) return 0;
  return -Math.log10(sampleValue / blankValue);
}

// ---------------- ANALYSIS ----------------
function analyze(zones) {
  const z1_rgb = analyzeRGB(zones[1]);
  const z2_rgb = analyzeRGB(zones[2]);
  const z3_rgb = analyzeRGB(zones[3]);

  // For NMPI-MDA: MORE BLUE = MORE MDA
  // Use Blue channel directly (not inverted absorbance)
  const blueIntensity = z1_rgb.avgB;
  
  // Calculate concentration from calibration curve
  // Using blue intensity directly
  const concentration = Math.max(0, (blueIntensity - INTERCEPT) / SLOPE);

  mdaValue.textContent = `${concentration.toFixed(2)} ÂµM`;
  mdaDetails.textContent = `Blue Intensity: ${blueIntensity.toFixed(2)} | RGB: (${Math.round(z1_rgb.avgR)}, ${Math.round(z1_rgb.avgG)}, ${Math.round(z1_rgb.avgB)})`;

  // Qualitative detection for RF and CCP based on blue intensity threshold
  // Adjust threshold based on your measurements
  const z2_blueDetected = z2_rgb.avgB > 100;
  const z3_blueDetected = z3_rgb.avgB > 100;

  rfStatus.textContent = z2_blueDetected ? "Detected" : "Not detected";
  rfStatus.className = `value ${z2_blueDetected ? "status-positive" : "status-negative"}`;

  ccpStatus.textContent = z3_blueDetected ? "Detected" : "Not detected";
  ccpStatus.className = `value ${z3_blueDetected ? "status-positive" : "status-negative"}`;

  resultsBox.style.display = "grid";
  drawCalibrationCurve(concentration, blueIntensity);
}

// ---------------- CALIBRATION CURVE ----------------
function drawCalibrationCurve(measuredConc, measuredBlueIntensity) {
  const concRange = [];
  const blueRange = [];
  
  // Generate calibration line from 0 to 50 ÂµM
  for (let c = 0; c <= 50; c++) {
    concRange.push(c);
    blueRange.push(SLOPE * c + INTERCEPT);
  }

  const calibrationTrace = {
    x: concRange,
    y: blueRange,
    type: 'scatter',
    mode: 'lines',
    name: 'Calibration Curve',
    line: { width: 3, color: '#3b82f6' }
  };

  const pointsTrace = {
    x: calibrationData.map(d => d.conc),
    y: calibrationData.map(d => d.abs),
    type: 'scatter',
    mode: 'markers',
    name: 'Calibration Points',
    marker: { size: 10, color: '#10b981' }
  };

  const sampleTrace = {
    x: [measuredConc],
    y: [measuredBlueIntensity],
    type: 'scatter',
    mode: 'markers',
    name: 'Your Sample',
    marker: { size: 14, symbol: 'diamond', color: '#ef4444' }
  };

  const layout = {
    title: `Blue Intensity = ${SLOPE.toFixed(2)} Ã— [MDA] + ${INTERCEPT.toFixed(1)}<br>RÂ² = ${R_SQUARED.toFixed(4)}`,
    xaxis: { 
      title: 'MDA Concentration (ÂµM)',
      range: [0, 50],
      showgrid: true,
      gridcolor: '#f0f0f0'
    },
    yaxis: { 
      title: 'Blue Channel Intensity (0-255)',
      range: [80, 260],  // Start from 80 to show baseline better
      showgrid: true,
      gridcolor: '#f0f0f0'
    },
    margin: { t: 80, b: 60, l: 60, r: 40 },
    plot_bgcolor: '#ffffff',
    paper_bgcolor: '#ffffff',
    showlegend: true
  };

  Plotly.newPlot('calibrationPlot', [calibrationTrace, pointsTrace, sampleTrace], layout, { responsive: true, displayModeBar: false });
}

// Initial empty plot
window.addEventListener('load', function() {
  if (typeof Plotly !== 'undefined') {
    drawCalibrationCurve(0, 0);
  } else {
    console.error('Plotly failed to load');
    document.getElementById('calibrationPlot').innerHTML = '<div style="text-align:center; padding:50px; color:#dc2626;">Error loading chart library. Please refresh the page.</div>';
  }
});
</script>
</body>
</html>
